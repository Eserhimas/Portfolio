# -*- coding: utf-8 -*-
"""isolation_forest_anomaly_detection_mammography.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ll_SOvBsJoxpTBtwUWPwn-_zZICXJP0P
"""

# essentials
import pandas as pd
import numpy as np

# visualization
import matplotlib.pyplot as plt
import plotly.express as px


# sklearn libraries
from sklearn.ensemble import IsolationForest
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.metrics import auc, roc_curve

# others
import warnings
import scipy.io
from google.colab import drive

# settings
warnings.filterwarnings('ignore')

# to fetch the dataset from google drive
drive.mount('/content/gdrive')

"""The original Mammography (Woods et al., 1993) data set was made available by the courtesy of Aleksandar Lazarevic. This dataset is publicly available in openML. It has 11,183 samples with 260 calcifications. If we look at predictive accuracy as a measure of goodness of the classifier for this case, the default accuracy would be 97.68% when every sample is labeled non-calcification. But, it is desirable for the classifier to predict most of the calcifications correctly. For outlier detection, the minority class of calcification is considered as outlier class and the non-calcification class as inliers.
[https://odds.cs.stonybrook.edu/mammography-dataset/](https://odds.cs.stonybrook.edu/mammography-dataset/)
"""

# loading the dataset .mat

path = '/content/gdrive/MyDrive/Repository/Datasets/mammography/mammography.mat'

data = scipy.io.loadmat(path)
data

# dataframe
df = pd.DataFrame(data['X'])
df.head()

y = data['y'].flatten()

y

df['y'] = y.tolist()

df.tail()

# normal and anomaly points.
# this step is for checking the percentage of the target values.
# Iy this way, if the dataset is imbalanced, handling it is considered.

norm = df[df['y'] == 0]['y'].count()
anom = df[df['y']==1]['y'].count()
tot = len(df)
print("Percentage of normal points: {} ({}%)".format(norm, round((norm/tot)*100,2)))
print("Percentage of anomaly points: {} ({}%)".format(norm, round((anom/tot)*100,2)))

df.describe()

# this scatter plot shows the outlier point according to the target variable.
c_code = {0:'blue', 1: 'red'}

colors = df['y'].apply(lambda x: c_code[x])

pd.plotting.scatter_matrix(df, c=colors, figsize=(16,12))
plt.show()

# splitting the target value
X = df.drop('y', axis=1)
y = df['y']

# scaling

X_scaled = StandardScaler().fit_transform(X)

# PCA is not necessary. Feel free to use all the datasets.
# This is just for the visualization.
pca = PCA(n_components=2)

princ_comp = pca.fit_transform(X_scaled) # training

df_pc = pd.DataFrame(data=princ_comp, columns=['PC1','PC2']) # newly created dataframe
df_pc.head()

# Implementing the isolation forest

if_model = IsolationForest(contamination=0.02) # normal points/anomaly points
if_model.fit(df_pc)

y_hat = if_model.predict(df_pc) # predictions

# isolation scores and anomaly data points

df_pc['if_scores'] = if_model.decision_function(df_pc)
df_pc['if_anomalies'] = y_hat

df_pc.head()

# replacing the values

df_pc['if_anomalies'] = df_pc['if_anomalies'].replace([-1, 1], ['Yes', 'No'])

# Visualizing the all dots

fig = px.scatter(df_pc, x='PC1', y='PC2', title = 'Normal & Anomaly Data Points')
fig.update_layout(
    font_family='Courier New',
    font_color='black',
    plot_bgcolor='white',
)

fig

# Visualizing the normal vs. anomalies

fig = px.scatter(df_pc, x='PC1', y='PC2',
                 title = 'Normal vs. Anomaly Points',
                 color='if_anomalies',
                 )
fig.update_layout(
    font_family='Courier New',
    font_color='black',
    plot_bgcolor='white',
)

fig

# Visualizing the scores

fig = px.scatter(df_pc, x='PC1', y='PC2',
                 title = 'Isolation Forest Scores',
                 color='if_scores',
                 color_continuous_scale=px.colors.sequential.Viridis)
fig.update_layout(
    font_family='Courier New',
    font_color='black',
    plot_bgcolor='white',
)

fig